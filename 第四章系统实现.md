## 第四章系统实现

本章是在第3章的基础上，对系统进行编程实现，介绍系统的软硬件开发环境和平台搭建配置文件，详细介绍各个功能模块的前端页面实现和后台业务逻辑实现，对各个功能的实现细节进行阐述。

### 4.1 软硬件环境

本节主要介绍系统搭建所需的软硬件开发环境要求。

#### 4.1.1 硬件环境

最低配置：CPU：四核 3.4GHZ以上。

硬盘空间：256G以上。

内存：4G以上。

#### 4.1.2软件环境

适合操作系统：Windows 7、Windows 10、Linux等，可跨平台。

数据库：MySQL 5.7。

IE要求：IE8.0以上。

其他要求：JDK1.8，TOMCAT 7.0，Maven3.3.9,Docker 20.10.17,ElasticSearch7.14.0,Redis7.0.4,RabbitMq:3.8

### 4.2 平台架构

教授面对面咨询问答系统采用前后端分离设计，前后端分离设计的好处在于降低了开发人员之间工作的耦合度，后端可以专注于业务逻辑的处理，前端专注于页面交互以及视图美化和展示。

#### 4.2.1 前端架构

教授面对面在线咨询问答系统前端采用HTML+CSS+JavaScript语言进行构建，基础框架选择Vue.js，采用Vue-Cli作为构建项目的脚手架,以及采用了ElementUI作为基础组件库，实现快速开发系统组件，并且统一了UI风格的作用。

**什么是Vue？**

![image-20220909152823332](./第四章系统实现.assets/image-20220909152823332.png)

根据官网的描述,Vue是一个渐进式的前端开发框架，也是一个用于创建单页面应用的开发框架，旨在更好地组织与简化Web开发。Vue所关注的核心是[MVC模式](https://zh.m.wikipedia.org/wiki/MVC)中的视图层，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互。

#### 4.2.2 后端架构

教授面对面在线咨询问答系统采用Java语言编写，开发框架选用SpringBoot框架

> SpringBoot是Java Spring框架的集大成者，它通过简化Spring的配置，以约定大于配置的思想删繁就简，大幅提升了Spring的配置过程，凭借优秀的对第三方的组件库的集成，已经成为JavaWeb开发的基础框架之一

数据库方面，本系统采用Mysql数据库，并且通过MybatisPlus框架作为ORM(Object Relational Mapping)对象关系映射框架，可以方便的对mysql数据库进行操作。

另外，本系统还引入了Redis数据库用作热点数据的查询缓存以及会话存储等功能。

> Redis是一款C语言实现的高性能NO-SQL数据库，凭借其优秀的性能成为广泛运用的缓存中间件，也被广泛运用在各种需要高性能存储，快速响应，高可用集群的搭建中。

在系统模块的解耦方面，本系统引入了RabbitMQ作为消息队列，用于本系统不同模块之间的信息通讯以及业务的异步操作，解耦.

> RabbitMQ是一款ErLang语言编写的高性能消息队列，尤其对于消息数据的安全性有很高的保证。

在搜索方面，本系统引入了ElasticSearch作为索引数据的查询引擎，用于实现全文检索，复杂检索等功能。使用倒排索引加快了响应的速度。

下面介绍系统用到的核心配置文件

1. springboot配置文件

   在系统的每个web模块下的resources下都有一个application.yaml文件，这个文件就是springboot的核心配置文件,主要用于配置系统用到的配置类的核心属性，例如数据库的链接参数，es的链接参数，事务相关的配置，对象存储的位置，邮件客户端的配置等等

2. maven配置文件

   本系统采用maven作为构建工具，因此每个模块下的pom.xml是系统构建的核心，这些文件主要定义了项目中模块之间的父子关系，用到的maven核心仓库中的依赖包信息，以及构建时候用到的打包工具和相关的打包配置

### 4.3 教授面对面系统的实现

#### 4.3.1 系统首页实现

暂时未完成，略过

#### 4.3.2 登录注册实现

###### 活动图

![image-20220909162003202](./第四章系统实现.assets/image-20220909162003202.png)

###### 流程图

![image-20220909161518840](./第四章系统实现.assets/image-20220909161518840.png)

###### 时序图-注册

![image-20220909161819778](./第四章系统实现.assets/image-20220909161819778.png)

###### 时序图-登录

![image-20220909161717733](./第四章系统实现.assets/image-20220909161717733.png)



注册方面系统提供邮箱注册，手机号注册以及第三方注册三种方案。

- 邮箱注册需要通过系统的邮箱验证码，输入用户名和密码之后进行注册

- 手机号注册需要通过手机短信验证码进行验证，输入用户名和密码进行注册
- 第三方注册可以通过微信和qq账号进行绑定注册。

注册功能的细节:

- 注册会对用户的密码进行加密
- 收到的验证码设置了缓存方案，超过90s会自动失效

登录功能与注册类似，可以通过用户名 密码登录，手机号登录，以及邮箱账号登录三种方式

登录功能的细节:

- 登录控制采用SaToken权限框架进行控制，当用户输入以正确的凭证登录之后后端接口会返回一个Token作为用户的会话凭据，并且将用户的会话信息存入Redis，前端访问后端接口必须携带Token凭据与后端进行通信。
- 后端对于Token的校验采用的SpringBoot的拦截器进行实现，也就是在用户访问需要登录权限的接口时，对用户的Token信息进行校验，如果校验失败则返回对应的错误信息
- 认证之后的鉴权也是通过SaToken实现的，我们为每个用户设置一个权限列表，用户每次访问需要权限控制的敏感资源都会被拦截，系统通过查询用户权限选择是否放行此次请求。

登录实现的核心代码

```java
 BaseUser loginUser = baseUserMapper.selectOne(new QueryWrapper<BaseUser>().eq("email", loginParams.getEmail()));
if (loginUser==null)throw new NotRegisterException();
if (!loginUser.getPassword().equals(SaSecureUtil.md5(loginParams.getPassword())))throw new BadCreditException();
StpUtil.login(loginUser.getId());
SaSession userSession = StpUtil.getSession(true);
loginUser.setPassword(null);
userSession.set("userInfo",loginUser);
return SaResult.ok().setMsg("登录成功").setData(StpUtil.getTokenInfo());
```

整体核心逻辑为，通过用户输入的凭据，进行加密之后与数据库进行匹配，匹配通过则颁发有效的Token，否则抛出异常。

用户鉴权的核心代码

```java
@Component
@Slf4j
public class PermissionConfig  implements StpInterface{
    @Autowired
    AdminService adminService;

    @Override
    public List<String> getPermissionList(Object id, String s) {
        Integer userId = Integer.parseInt((String) id);
        List<Permission>list=adminService.getPermissionList(userId);
        return list.stream().map(Permission::getPermissionCode).collect(Collectors.toList());
    }

    @Autowired
    RoleService roleService;
    @Override
    public List<String> getRoleList(Object id, String s) {
        Integer userId = (Integer) id;
        List<Integer> rids = adminService.roleIdList(userId);
        List<Role> roles = roleService.listByIds(rids);
        return roles.stream().map(Role::getName).collect(Collectors.toList());
    }
}
```

通过重写SaToken框架中获取用户角色的和权限的获取逻辑来得到用户相关的权限校验码，以此为凭据进行权限的校验。然后只需要给敏感资源接口加上对应的注解SaCheckPermission，使用Spring的Aop切面特性就可以进行拦截请求并且鉴权了

```java
@SaCheckPermission("pre_pro:list")
@GetMapping("/professor/all_pre")
public SaResult getAllPreProfessor()
{
    List<BaseUser> preProfessors = baseUserService.list(new QueryWrapper<BaseUser>().eq("user_type", UserType.PRE_PROFESSOR.getCode()));
    return SaResult.ok().setData(preProfessors).setMsg("获取成功");
}
```

#### 4.3.3 用户发表提问以及获取回答实现

###### 流程图

![image-20220917145612333](./第四章系统实现.assets/image-20220917145612333.png)

提问与回答的主要过程是： 咨询者在平台上发表问题，发表完成后选择需要咨询的教授（可多选），然后提交到后台由管理员进行审核，问题审核之后推送到对应的教授，如果不通过给出反馈修改意见，然后生成系统消息推送到咨询者指导其根据意见进行修改，如果所有的教授都拒绝回答，则也会生成系统消息返回用户端，引导其重新发起提问流程。

发布问题关键代码: 发布问题会向教授发送通知，所以需要添加事务管理

```java
@Transactional(rollbackFor = Exception.class)
public void pubQuestion(Question dest, List<Integer> proIds)
{
    int curUserId = StpUtil.getLoginIdAsInt();
    questionMapper.insert(dest);
    for (Integer proId : proIds)
    {
        SystemMsg systemMsg = baseMsg();
        systemMsg.setToUserId(proId);
        systemMsg.setMsgType(SysMsgType.USER_QUESTION.getCode());
        systemMsg.setMsgContent("用户"+curUserId
                                +"邀请你回答"+dest.getQuestionTitle()+"问题id:"+dest.getId());
        systemMsgMapper.insert(systemMsg);
        QuestionProfessor qp = new QuestionProfessor();
        qp.setQuestionId(dest.getId());
        qp.setProfessorId(proId);
        questionProfessorMapper.insert(qp);
    }
}
```



问题审核关键代码:

```java
Question question = questionMapper.selectById(auditQuestionParam.getQuestionId());
question.setQuestionStatus(auditQuestionParam.getQuestionStatus());
String sysMsgContent = null;
if (auditQuestionParam.getQuestionStatus().equals(QuestionStatus.FORBIDDEN.getCode()))
{
    sysMsgContent="您的问题<"+question.getQuestionTitle()+">已经被封禁，原因是"+auditQuestionParam.getComment();
}
else  if (auditQuestionParam.getQuestionStatus().equals(QuestionStatus.NORMAL.getCode()))
{
    sysMsgContent="您的问题<"+question.getQuestionTitle()+">发布成功，请等待回答";
}
else  if (auditQuestionParam.getQuestionStatus().equals(QuestionStatus.AUDIT_FAILURE.getCode()))
{
    sysMsgContent="您的问题<"+question.getQuestionTitle()+">审核不通过，请根据意见修改后提交审核";
}
SystemMsg systemMsg = new SystemMsg();
systemMsg.setMsgContent(sysMsgContent);
systemMsg.setFromUserId(0);
systemMsg.setToUserId(question.getUserId());
systemMsg.setMsgType(SysMsgType.USER_QUESTION.getCode());
systemMsgMapper.insert(systemMsg);
return SaResult.ok().setMsg("审核成功");
```



#### 4.3.4 教授资格申请

###### 活动图

![image-20220917134915739](./第四章系统实现.assets/image-20220917134915739.png)

###### 流程图

![image-20220917142014657](./第四章系统实现.assets/image-20220917142014657.png)

###### 时序图

![image-20220917143930891](./第四章系统实现.assets/image-20220917143930891.png)

教授资格的申请的实现主要有如下要点

- 普通咨询者想成为志愿教授，需要提交学信网可查的学历数据以及相关的教育经历简历

- 在申请志愿教授时候，需要指定自己擅长的领域

- 管理员需要根据提交的教授简历信息，以及学信网的数据综合审核资质，决定是否通过

  ，并且设置教授的回答领域

核心代码:

1. 志愿教授申请请求，上传个人信息

```java
@PostMapping("/apply_pro")
@SaCheckLogin
public SaResult requestToBeProfessor(@Validated @RequestBody ReqProfessorParams reqProfessorParams)
{
    SaSession userSession = StpUtil.getSession();
    BaseUser userInfo= (BaseUser) userSession.get("userInfo");
    String cvFileName = userInfo.getCvFileName();
    if (StringUtil.isNullOrEmpty(cvFileName))
        return SaResult.error().setCode(400).setMsg("请先上传简历");
    if (userInfo.getUserType()==UserType.PRE_PROFESSOR.getCode())
        return SaResult.error().setCode(400).setMsg("已经申请过了,请不要重复申请!");
    userInfo.setCardId(reqProfessorParams.getCardId());
    userInfo.setBirthday(reqProfessorParams.getBirthday());
    userInfo.setRealName(reqProfessorParams.getRealName());
    userInfo.setUserType(UserType.PRE_PROFESSOR.getCode());
    userInfo.setCvFileName(cvFileName);
    userSession.set("userInfo",userInfo);
    baseUserService.updateById(userInfo);
    return SaResult.ok().setMsg("申请成功,请等待审核");
}
```

2. 上传简历文件

```java
 @Value("${file.upload.cv.path}")
private String UPLOAD_CV_FOLDER;
public SaResult uploadCVFile(MultipartFile file)
{
    String fname = file.getOriginalFilename();
    //自定义文件名：UUID+扩展名 避免同名覆盖
    String newName = UUID.randomUUID().toString()+ "." + fname.substring(fname.lastIndexOf(".")+1);
    Path path = Paths.get(UPLOAD_CV_FOLDER + newName);
    try
    {
        file.transferTo(path);
        BaseUser me = baseUserMapper.selectById(StpUtil.getLoginIdAsInt());
        me.setCvFileName(newName);
        baseUserMapper.updateById(me);
        SaSession UserSession = StpUtil.getSession(true);
        UserSession.set("userInfo",me);
        return SaResult.ok().setMsg("上传成功");
    }catch (IOException e)
    {
        e.printStackTrace();
        return SaResult.error().setMsg("上传失败 异常为:"+e.getMessage());
    }
}
```

3. 管理员获取学信网学历相关数据

   ```java
   @GetMapping("/edu_datasource/{userId}")
   public SaResult getUserEduDataSource(@PathVariable Integer userId)
   {
       BaseUser baseUser = baseUserService.getById(userId);
       XueXinWangData xueXinWangData = xueXinWangDataService.getOne(
           new QueryWrapper<XueXinWangData>().eq("card_id",baseUser.getCardId())
       );
       List<EduExperience> experiences = eduExperienceService.list(new QueryWrapper<EduExperience>().eq("edu_data_source_id", xueXinWangData.getId()));
       Map<String,Object> res=new HashMap<>();
       res.put("baseInfo",xueXinWangData);
       res.put("experience",experiences);
       return SaResult.ok().setMsg("获取学信网数据成功").setData(res);
   }
   ```

4. 通过教授审核

   ```java
   @PostMapping("/professor/access/{userId}")
   public SaResult accessProfessorProfile(@PathVariable Integer userId)
   {
       BaseUser professor = baseUserService.getById(userId);
       professor.setUserType(UserType.PROFESSOR.getCode());
       baseUserService.updateById(professor);
       return SaResult.ok().setMsg("教授申请审核通过");
   }
   ```

   